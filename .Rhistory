coord_flip()
bd_demog_eye %>% ggplot(aes(overallHealth, group=townsendDep1, fill = townsendDep1)) +
geom_bar()+
coord_flip() +
facet_grid(. ~ smoke1stAss)
bd_demog_eye %>% ggplot(aes(overallHealth, group=townsendDep1, fill = townsendDep1)) +
geom_bar()+
coord_flip() +
facet_grid(smoke1stAss ~ .)
bd_demog_eye %>% ggplot(aes(overallHealth, group=townsendDep1, fill = townsendDep1)) +
geom_bar()+
coord_flip()
table1 <- bd_demog_eye %>% group_by(smoke1stAss) %>% summarise(Freq=n()) %>% ungroup() %>%
mutate(pc=round(100*Freq/(sum(Freq)),1)) %>% ungroup()
table1 %>% kable(col.names = c("Smoking status at 1st assessment", "#", "%")) %>%
kable_styling(full_width = F, position = "left")
View(eid_diab_dr)
View(eid_diab_dr)
View(eid_ded)
View(eid_ins_med)
View(eid_glauc)
nrow(eid_glauc)
min(eid_glauc$age)
min(eid_glauc$minGlaucAge)
min(eid_glauc$minGlaucAge, na.rm=TRUE)
max(eid_glauc$minGlaucAge, na.rm=TRUE)
printT(sum(eid_glauc$Laser]))
printT(sum(eid_glauc$Laser))
printT(sum(eid_glauc$glaucLaser))
printT(sum(eid_glauc$glaucLaser, na.rm=TRUE))
printT(sum(eid_glauc$glaucSurg, na.rm=TRUE))
printT(nrow(eid_cat))
min(eid_cat$minCatAge, na.rm=TRUE)
max(eid_cat$minCatAge, na.rm=TRUE)
printT(sum(eid_cat$catSurg, na.rm=TRUE))
printT(nrow(eid_ded))
min(eid_ded$minDedAge, na.rm=TRUE)
max(eid_ded$minDedAge, na.rm=TRUE)
eid_ins_med2 <- eid_ins_med2 %>% filter(f.6177.0.0=="Insulin" | f.6177.0.1=="Insulin" |  f.6177.0.2=="Insulin" |  f.6177.1.0=="Insulin" | f.6177.1.1=="Insulin" |
f.6177.1.2=="Insulin" | f.6177.2.0=="Insulin" | f.6177.2.1=="Insulin" |  f.6177.2.2=="Insulin" | f.6177.3.0=="Insulin" |
f.6177.3.1=="Insulin" |  f.6177.3.2=="Insulin") %>%
mutate(insMed2=1) %>% select(f.eid, insMed2)
#self-reported eye affected by diabetic eye disease
bd_ded_eye <- bd %>% select(f.eid, f.5890.0.0, f.5890.1.0, f.5890.2.0, f.5890.3.0)
bd_ded_eye <- bd_ded_eye[rowSums(!is.na(bd_ded_eye[2:5]))>=1, ]
bd_ded_eye <- bd_ded_eye %>% mutate(dedEye=1) %>% select(f.eid, dedEye)
#self-reported age when diagnosed with diabetic eye disease
bd_ded_age <- bd %>% select(f.eid, f.5901.0.0, f.5901.1.0, f.5901.2.0, f.5901.3.0)
bd_ded_age[bd_ded_age<0] <- NA
bd_ded_age <- bd_ded_age[rowSums(!is.na(bd_ded_age[2:5]))>=1, ]
bd_ded_age <- bd_ded_age %>% rowwise() %>% mutate(minDedAge=min(c(f.5901.0.0, f.5901.1.0, f.5901.2.0, f.5901.3.0), na.rm = TRUE)) %>% select(f.eid, minDedAge)
#create list of ids with self-reported diabetic eye disease
eid_ded <- full_join(bd_ded_age, bd_ded_eye, by = "f.eid")
rm(bd_ded_age, bd_ded_eye)
#self-reported Dr diagnosed diabetes - count 'yes' only
eid_diab_dr <-  bd %>% select(f.eid, f.2443.0.0, f.2443.1.0, f.2443.2.0, f.2443.3.0)
eid_diab_dr <- eid_diab_dr %>% filter(grepl("Yes", f.2443.0.0)|grepl("Yes", f.2443.1.0)|grepl("Yes", f.2443.2.0)|grepl("Yes", f.2443.3.0)) %>%
mutate(diabDr=1) %>% select(f.eid, diabDr)
# self reported meds count code 3 = insulin only
eid_ins_med <- bd %>% select(f.eid, f.6153.0.0, f.6153.0.1, f.6153.0.2, f.6153.0.3, f.6153.1.0, f.6153.1.1, f.6153.1.2, f.6153.1.3, f.6153.2.0,
f.6153.2.1, f.6153.2.2, f.6153.2.3, f.6153.3.0, f.6153.3.1, f.6153.3.2, f.6153.3.3)
eid_ins_med <- eid_ins_med %>% filter(f.6153.0.0=="Insulin" | f.6153.0.1=="Insulin" |  f.6153.0.2=="Insulin" |  f.6153.0.3=="Insulin" |  f.6153.1.0=="Insulin" |
f.6153.1.1=="Insulin" | f.6153.1.2=="Insulin" |  f.6153.1.3=="Insulin" |  f.6153.2.0=="Insulin" | f.6153.2.1=="Insulin" |
f.6153.2.2=="Insulin" |  f.6153.2.3=="Insulin" | f.6153.3.0=="Insulin" |  f.6153.3.1=="Insulin" |  f.6153.3.2=="Insulin" |
f.6153.3.3=="Insulin") %>%
mutate(insMed=1) %>% select(f.eid, insMed)
# self reported meds count code 3 = insulin only -  not sure why there's a second field
eid_ins_med2 <- bd %>% select(f.eid, f.6177.0.0, f.6177.0.1, f.6177.0.2, f.6177.1.0, f.6177.1.1,
f.6177.1.2, f.6177.2.0, f.6177.2.1, f.6177.2.2, f.6177.3.0, f.6177.3.1, f.6177.3.2)
eid_ins_med2 <- eid_ins_med2 %>% filter(f.6177.0.0=="Insulin" | f.6177.0.1=="Insulin" |  f.6177.0.2=="Insulin" |  f.6177.1.0=="Insulin" | f.6177.1.1=="Insulin" |
f.6177.1.2=="Insulin" | f.6177.2.0=="Insulin" | f.6177.2.1=="Insulin" |  f.6177.2.2=="Insulin" | f.6177.3.0=="Insulin" |
f.6177.3.1=="Insulin" |  f.6177.3.2=="Insulin") %>%
mutate(insMed2=1) %>% select(f.eid, insMed2)
#put diabetes dx and two insulin self-report fields together
eid_diab_ins <- full_join(eid_ins_med, eid_ins_med2, by = "f.eid")
eid_diab_ins <- full_join(eid_diab_ins, eid_diab_dr, by = "f.eid")
rm(eid_diab_dr, eid_ins_med, eid_ins_med2)
#self-reported eye affected by diabetic eye disease
bd_ded_eye <- bd %>% select(f.eid, f.5890.0.0, f.5890.1.0, f.5890.2.0, f.5890.3.0)
bd_ded_eye <- bd_ded_eye[rowSums(!is.na(bd_ded_eye[2:5]))>=1, ]
bd_ded_eye <- bd_ded_eye %>% mutate(dedEye=1) %>% select(f.eid, dedEye)
#self-reported age when diagnosed with diabetic eye disease
bd_ded_age <- bd %>% select(f.eid, f.5901.0.0, f.5901.1.0, f.5901.2.0, f.5901.3.0)
bd_ded_age[bd_ded_age<0] <- NA
bd_ded_age <- bd_ded_age[rowSums(!is.na(bd_ded_age[2:5]))>=1, ]
bd_ded_age <- bd_ded_age %>% rowwise() %>% mutate(minDedAge=min(c(f.5901.0.0, f.5901.1.0, f.5901.2.0, f.5901.3.0), na.rm = TRUE)) %>% select(f.eid, minDedAge)
#create list of ids with self-reported diabetic eye disease
eid_ded <- full_join(bd_ded_age, bd_ded_eye, by = "f.eid")
rm(bd_ded_age, bd_ded_eye)
#self-reported Dr diagnosed diabetes - count 'yes' only
eid_diab_dr <-  bd %>% select(f.eid, f.2443.0.0, f.2443.1.0, f.2443.2.0, f.2443.3.0)
eid_diab_dr <- eid_diab_dr %>% filter(grepl("Yes", f.2443.0.0)|grepl("Yes", f.2443.1.0)|grepl("Yes", f.2443.2.0)|grepl("Yes", f.2443.3.0)) %>%
mutate(diabDr=1) %>% select(f.eid, diabDr)
# self reported meds count code 3 = insulin only
eid_ins_med <- bd %>% select(f.eid, f.6153.0.0, f.6153.0.1, f.6153.0.2, f.6153.0.3, f.6153.1.0, f.6153.1.1, f.6153.1.2, f.6153.1.3, f.6153.2.0,
f.6153.2.1, f.6153.2.2, f.6153.2.3, f.6153.3.0, f.6153.3.1, f.6153.3.2, f.6153.3.3)
eid_ins_med <- eid_ins_med %>% filter(f.6153.0.0=="Insulin" | f.6153.0.1=="Insulin" |  f.6153.0.2=="Insulin" |  f.6153.0.3=="Insulin" |  f.6153.1.0=="Insulin" |
f.6153.1.1=="Insulin" | f.6153.1.2=="Insulin" |  f.6153.1.3=="Insulin" |  f.6153.2.0=="Insulin" | f.6153.2.1=="Insulin" |
f.6153.2.2=="Insulin" |  f.6153.2.3=="Insulin" | f.6153.3.0=="Insulin" |  f.6153.3.1=="Insulin" |  f.6153.3.2=="Insulin" |
f.6153.3.3=="Insulin") %>%
mutate(insMed=1) %>% select(f.eid, insMed)
# self reported meds count code 3 = insulin only -  not sure why there's a second field
eid_ins_med2 <- bd %>% select(f.eid, f.6177.0.0, f.6177.0.1, f.6177.0.2, f.6177.1.0, f.6177.1.1,
f.6177.1.2, f.6177.2.0, f.6177.2.1, f.6177.2.2, f.6177.3.0, f.6177.3.1, f.6177.3.2)
eid_ins_med2 <- eid_ins_med2 %>% filter(f.6177.0.0=="Insulin" | f.6177.0.1=="Insulin" |  f.6177.0.2=="Insulin" |  f.6177.1.0=="Insulin" | f.6177.1.1=="Insulin" |
f.6177.1.2=="Insulin" | f.6177.2.0=="Insulin" | f.6177.2.1=="Insulin" |  f.6177.2.2=="Insulin" | f.6177.3.0=="Insulin" |
f.6177.3.1=="Insulin" |  f.6177.3.2=="Insulin") %>%
mutate(insMed2=1) %>% select(f.eid, insMed2)
#put diabetes dx and two insulin self-report fields together
eid_diab_ins <- full_join(eid_ins_med, eid_ins_med2, by = "f.eid")
eid_diab_ins <- full_join(eid_diab_ins, eid_diab_dr, by = "f.eid")
rm(eid_diab_dr, eid_ins_med, eid_ins_med2)
printT(nrow(eid_diab_dr))
View(eid_diab_ins)
printT(sum(eid_diab_ins$diabDr))
printT(sum(eid_diab_ins$diabDr, na.rm=TRUE))
printT(nrow(eid_diab_ins))
#   read in labelled full dataset
setwd("Q:\\assessment-centre")
clc
bd <- read.table("Q:\\assessment-centre\\ukb46811.tab", header=TRUE, sep="\t")
pwd
cd
cw
read.csv('baselineData.csv')
read.csv('baselineDataSummary.csv.csv')
read.csv('baselineDataSummary.csv')
read.csv('baselineData.csv')
rm(list=ls())
setwd('/Users/fabianyii/power')
# install.packages('stringr')
# install.packages('doParallel')
library('stringr')
library(usethis)
library(doParallel)                     # package for parallelisation
registerDoParallel(8)                   # set number of cores to 8 (8 on my mac)
d <- read.csv('data/power.csv')         # read the "stamps" data
d <- d[,-1]
# install.packages("devtools")
library(devtools)
# install_github("imarinfr/vf1/source")
# install.packages('RColorBrewer')
library("visualFields")
library('RColorBrewer')
source('code/empty_plot.R')             # create empty plot (argument: give title)
source('code/plot_avg.R')               # fit the average curve for each px
#create data frame to record power at each iteration for all patients
MD_slope <- c(0.05, 0.1, 0.2, 0.5, 1, 2, 4)
pe <- data.frame(no=rep( 1:7, 450), id=rep(1:30, each=105), l1=0, l2=0, l3=0, l4=0, l5=0,
slope=MD_slope*52/5, pow=0)
#configure the dataset to be compatable with visualFields
d <- d[,c(1,9,5,6,8,7,12,13,14,15,17:70)]
names(d)[c(2:10)] <- c('eye','date','time','age','type','fpr','fnr','fl','duration')
d$date <- as.Date(d$date)
d$id <- rep(1:30, each=12)     # make px id range from 1-30
########################### Simulation begins here #################################
dat <- data.frame(n=1:700, rate=unique(pe$slope) ,p=0)   # empty data frame to record p-val at each run
num_series <- 5                                          # how many VFs to include in a series?
set.seed(18143)
for (i in 1:30) {
a <- d[which(d$id==unique(d$id)[i]),]                       # "a" = subset where px id = 'i'
if(mean(apply(a[,-c(1:10,36,45)],2,mean) > 10)*52 > 8){     # check that there are >8 test locations with mean sensitivity (across 12 tests) > 10dB
#Empty plot for each px (Power vs Progression Signal; log scale for x-axis)
empty_plot(title=paste0('Px ', unique(pe$id)[i]) )
# 'k' (th) iteration (15 sets of 5 progressing locations).
# A power curve is produced after each 'k' iteration.
for(k in 1:15) {
# mean sensitivity across 12 tests at each location (except blind spot)
col <- apply(a[,-c(1:10,36,45)],2,mean)
# which columns (test locations) with mean sensitivity > 10dB?
clm <- as.numeric(str_replace_all(rownames(cbind(col[which(as.numeric(col > 10) == 1)])), 'L','')) +10
# random selection of 5 eligible locations (columns)
neg <- sample(clm, 5, replace=FALSE )
# data frame to record power at K(th) iteration (for plotting purposes)
plot_res <- pe[which(pe$no==min(pe$no) & pe$id==unique(pe$id)[i])[k] :
which(pe$no==max(pe$no) & pe$id==unique(pe$id)[i])[k], ]
# record the progressing locations (columns) in both 'plot_res' & 'pe'
for (l in 1:5) { plot_res[,l+2] <- neg[l] }
pe[which(pe$no==min(pe$no) & pe$id==unique(d$id)[i])[k] :
which(pe$no==max(pe$no) & pe$id==unique(d$id)[i])[k], 3:7] <- plot_res[,3:7]
# 'o' (th) run (each run = 7 progression signals + PoPLR)
for (o in 1:100) {
a <- d[which(d$id==unique(d$id)[i]),]                     # 'a' = subset where px id = 'i'
# a <- a[1:num_series,]                                     # select the first 'num_series' VFs
# a <- a[sample(1:num_series, num_series, replace=FALSE),]  # randomly reorder the 'num_series' rows
a <- a[sample(12,5),]                                     # select 'num_series' VFs from the entire series
for (q in 1:4) { a$date[q+1] <- a$date[1] + 180*q }       # change test intervals to 6mths
# The reordered series is evaluated here across 7 different rates of progression
dat[which(dat$rate== unique(pe$slope)[1] )[o]: which(dat$rate== tail(unique(pe$slope),1) )[o],]$p <-  # record p-values at each run in 'dat'
foreach (s = 1:7, .combine='c') %dopar% {                                                           # parallelisation (7 cores employed to execute lines 77-81)
prog <- a
for (j in 2:num_series){ prog[j,neg] <- a[j,neg] - unique(pe$slope)[s]*(j-1)/2 }  # inject progression signal
poplr(prog)$cslp  # run PoPLR on the modified series to return p-val
}
# print(paste0('Px',i ,': ' ,k,' out of 15 iterations: ',o,' run(s) completed!'))  # 'live' report on progress in console
}
# compute power (proportion of p<0.05) and record in 'plot_res'
for (s in 1:7) { plot_res[s,]$pow <- length(which(dat[which(dat$rate==unique(dat$rate[s])),]$p<0.05))/100 }
# copy power from 'plot_res' to 'pe'
pe[which(pe$no==min(pe$no) & pe$id==unique(d$id)[i])[k] : which(pe$no==max(pe$no) & pe$id==unique(d$id)[i])[k], 9] <- plot_res$pow
# plot power curves #
x <- MD_slope
lines(x ,plot_res$pow*100, col='gray' )
print(paste0('Px',i ,': ' ,k,' out of 15 iterations completed!'))  # 'live' report on progress in console
} }
plot_avg(data=pe, i, legend='off')      # add average power curve
axis(2, cex.axis=1.6)
}
write.csv(pe, 'n5_power.csv')    # save result
pe
rm(list=ls())
setwd('/Users/fabianyii/power')
# install.packages("remotes")
library(remotes)
# install_github("imarinfr/vf1/source")
# install.packages('RColorBrewer')
library("visualFields")
library('RColorBrewer')
library('plotrix')
source('code/vf_config.R')                              # load function to configure vf data based on 'visualFields' requirements
source('code/empty_plot.R')                             # '' create empty plot (argument: give title)
source('code/plot_indiv.R')                             # '' fit (15) individual curves for each px
source('code/plot_avg.R')                               # '' fit the average curve for each px
source('code/plot_grayscale_sparklines.R')              # grayscale with sparklines
# read raw data (power; n=12) into r
d <- read.csv('n5_power.csv'); d <- d[,-1]
# read visual field raw data into r & configuration
vf <- read.csv('data/power.csv'); vf <- vf[,-1]
vf <- vf_config(vf, npx=30, nrow=12)
# 30 colour codes for 30 patients
col <- c(brewer.pal(12, 'Paired'),brewer.pal(8, 'Dark2'),brewer.pal(8, 'Accent'),brewer.pal(8, 'Set2'))
rm(list=ls())
setwd('/Users/fabianyii/power')
# install.packages("remotes")
library(remotes)
# install_github("imarinfr/vf1/source")
# install.packages('RColorBrewer')
library("visualFields")
library('RColorBrewer')
library('plotrix')
source('code/vf_config.R')                              # load function to configure vf data based on 'visualFields' requirements
source('code/empty_plot.R')                             # '' create empty plot (argument: give title)
source('code/plot_indiv.R')                             # '' fit (15) individual curves for each px
source('code/plot_avg.R')                               # '' fit the average curve for each px
source('code/plot_grayscale_sparklines.R')              # grayscale with sparklines
# read raw data (power; n=12) into r
d <- read.csv('data/n5_power.csv'); d <- d[,-1]
# read visual field raw data into r & configuration
vf <- read.csv('data/power.csv'); vf <- vf[,-1]
vf <- vf_config(vf, npx=30, nrow=12)
# 30 colour codes for 30 patients
col <- c(brewer.pal(12, 'Paired'),brewer.pal(8, 'Dark2'),brewer.pal(8, 'Accent'),brewer.pal(8, 'Set2'))
pdf(file='plots/plot_indiv.pdf', width=6, height=6)
for(i in 30){
empty_plot(data=vf, title='')                                    # create empty plot
plot_indiv(data=d, px=i)                                                       # fit all individual curves for 'i'th px
plot_avg(data=d, px=i, legend='on')                                            # fit the average curve for the 'i'th px
axis(2, cex.axis=1.6)
}
dev.off()
rm(list=ls())
setwd('/Users/fabianyii/power')
# install.packages("remotes")
library(remotes)
# install_github("imarinfr/vf1/source")
# install.packages('RColorBrewer')
library("visualFields")
library('RColorBrewer')
library('plotrix')
source('code/vf_config.R')                              # load function to configure vf data based on 'visualFields' requirements
source('code/empty_plot.R')                             # '' create empty plot (argument: give title)
source('code/plot_indiv.R')                             # '' fit (15) individual curves for each px
source('code/plot_avg.R')                               # '' fit the average curve for each px
source('code/plot_grayscale_sparklines.R')              # grayscale with sparklines
# read raw data (power; n=12) into r
d <- read.csv('data/n5_power.csv'); d <- d[,-1]
# read visual field raw data into r & configuration
vf <- read.csv('data/power.csv'); vf <- vf[,-1]
vf <- vf_config(vf, npx=30, nrow=12)
# 30 colour codes for 30 patients
col <- c(brewer.pal(12, 'Paired'),brewer.pal(8, 'Dark2'),brewer.pal(8, 'Accent'),brewer.pal(8, 'Set2'))
############# Power vs Progression Signal for each patient (in separate plots) ##############
pdf(file='plots/plot_indiv.pdf', width=6, height=6)
for(i in 1:30){
empty_plot(data=vf, title=paste0('Px', i))                                    # create empty plot
plot_indiv(data=d, px=i)                                                       # fit all individual curves for 'i'th px
plot_avg(data=d, px=i, legend='on')                                            # fit the average curve for the 'i'th px
axis(2, cex.axis=1.6)
}
dev.off()
pdf(file='plots/grayscale_sparklines_px.pdf', width=6, height=6)
num_VF <- 5 # number of VFs per series
lwd <- 2.5  # sparkline width
for(i in 1:30){
VF_series <- subset(vf, id==i)[1:num_VF,]   # extract 'num_VF' VFs from px i's VF series
mean_series <- vfmean(VF_series, by='eye') # mean of 'num_VF' VFs
grayscale_sparklines(vf=mean_series, vf_series=VF_series, 's', cex=0.01, lwd=lwd)
}
dev.off()
a
i=1
a <- d[which(d$id==unique(d$id)[i]),]
a
rm(list=ls())
setwd('/Users/fabianyii/power')
# install.packages('stringr')
# install.packages('doParallel')
library('stringr')
library(usethis)
library(doParallel)                     # package for parallelisation
registerDoParallel(8)                   # set number of cores to 8 (8 on my mac)
d <- read.csv('data/power.csv')         # read the "stamps" data
d <- d[,-1]
# install.packages("devtools")
library(devtools)
# install_github("imarinfr/vf1/source")
# install.packages('RColorBrewer')
library("visualFields")
library('RColorBrewer')
source('code/empty_plot.R')             # create empty plot (argument: give title)
source('code/plot_avg.R')               # fit the average curve for each px
#create data frame to record power at each iteration for all patients
MD_slope <- c(0.05, 0.1, 0.2, 0.5, 1, 2, 4)
pe <- data.frame(no=rep( 1:7, 450), id=rep(1:30, each=105), l1=0, l2=0, l3=0, l4=0, l5=0,
slope=MD_slope*52/5, pow=0)
#configure the dataset to be compatable with visualFields
d <- d[,c(1,9,5,6,8,7,12,13,14,15,17:70)]
names(d)[c(2:10)] <- c('eye','date','time','age','type','fpr','fnr','fl','duration')
d$date <- as.Date(d$date)
d$id <- rep(1:30, each=12)     # make px id range from 1-30
dat <- data.frame(n=1:700, rate=unique(pe$slope) ,p=0)   # empty data frame to record p-val at each run
num_series <- 5                                          # how many VFs to include in a series?
set.seed(18143)
a <- d[which(d$id==unique(d$id)[i]),]
i=2
a <- d[which(d$id==unique(d$id)[i]),]
a
a[,-c(1:10,36,45)]
mean(apply(a[1:num_series, -c(1:10,36,45)],2,mean) > 10)*52 > 8
a
apply(a[,-c(1:10,36,45)],2,mean)
a[1:num_series,-c(1:10,36,45)]
col <- apply(a[1:num_series,-c(1:10,36,45)],2,mean)
col
as.numeric(str_replace_all(rownames(cbind(col[which(as.numeric(col > 10) == 1)])), 'L',''))
as.numeric(str_replace_all(rownames(cbind(col[which(as.numeric(col > 10) == 1)])), 'L','')) +10
clm <- as.numeric(str_replace_all(rownames(cbind(col[which(as.numeric(col > 10) == 1)])), 'L','')) +10
neg <- sample(clm, 5, replace=FALSE )
neg
rm(list=ls())
setwd('/Users/fabianyii/power')
# install.packages('stringr')
# install.packages('doParallel')
library('stringr')
library(usethis)
library(doParallel)                     # package for parallelisation
registerDoParallel(8)                   # set number of cores to 8 (8 on my mac)
d <- read.csv('data/power.csv')         # read the "stamps" data
d <- d[,-1]
# install.packages("devtools")
library(devtools)
# install_github("imarinfr/vf1/source")
# install.packages('RColorBrewer')
library("visualFields")
library('RColorBrewer')
source('code/empty_plot.R')             # create empty plot (argument: give title)
source('code/plot_avg.R')               # fit the average curve for each px
#create data frame to record power at each iteration for all patients
MD_slope <- c(0.05, 0.1, 0.2, 0.5, 1, 2, 4)
pe <- data.frame(no=rep( 1:7, 450), id=rep(1:30, each=105), l1=0, l2=0, l3=0, l4=0, l5=0,
slope=MD_slope*52/5, pow=0)
#configure the dataset to be compatable with visualFields
d <- d[,c(1,9,5,6,8,7,12,13,14,15,17:70)]
names(d)[c(2:10)] <- c('eye','date','time','age','type','fpr','fnr','fl','duration')
d$date <- as.Date(d$date)
d$id <- rep(1:30, each=12)     # make px id range from 1-30
########################### Simulation begins here #################################
dat <- data.frame(n=1:700, rate=unique(pe$slope) ,p=0)   # empty data frame to record p-val at each run
num_series <- 5                                          # how many VFs to include in a series?
set.seed(18143)
for (i in 1:30) {
a <- d[which(d$id==unique(d$id)[i]),]                                    # "a" = subset where px id = 'i'
if(mean(apply(a[1:num_series, -c(1:10,36,45)],2,mean) > 10)*52 > 8){     # check that there are >8 test locations with mean sensitivity (across 5 tests) > 10dB
#Empty plot for each px (Power vs Progression Signal; log scale for x-axis)
empty_plot(title=paste0('Px ', unique(pe$id)[i]) )
# 'k' (th) iteration (15 sets of 5 progressing locations).
# A power curve is produced after each 'k' iteration.
for(k in 1:15) {
# mean sensitivity across 12 tests at each location (except blind spot)
col <- apply(a[1:num_series, -c(1:10,36,45)], 2, mean)
# which columns (test locations) with mean sensitivity > 10dB?
clm <- as.numeric(str_replace_all(rownames(cbind(col[which(as.numeric(col > 10) == 1)])), 'L','')) +10
# random selection of 5 eligible locations (columns)
neg <- sample(clm, 5, replace=FALSE )
# data frame to record power at K(th) iteration (for plotting purposes)
plot_res <- pe[which(pe$no==min(pe$no) & pe$id==unique(pe$id)[i])[k] :
which(pe$no==max(pe$no) & pe$id==unique(pe$id)[i])[k], ]
# record the progressing locations (columns) in both 'plot_res' & 'pe'
for (l in 1:5) { plot_res[,l+2] <- neg[l] }
pe[which(pe$no==min(pe$no) & pe$id==unique(d$id)[i])[k] :
which(pe$no==max(pe$no) & pe$id==unique(d$id)[i])[k], 3:7] <- plot_res[,3:7]
# 'o' (th) run (each run = 7 progression signals + PoPLR)
for (o in 1:100) {
a <- d[which(d$id==unique(d$id)[i]),]                     # 'a' = subset where px id = 'i'
# a <- a[1:num_series,]                                     # select the first 'num_series' VFs
# a <- a[sample(1:num_series, num_series, replace=FALSE),]  # randomly reorder the 'num_series' rows
a <- a[sample(12,5),]                                     # select 'num_series' VFs from the entire series
for (q in 1:4) { a$date[q+1] <- a$date[1] + 180*q }       # change test intervals to 6mths
# The reordered series is evaluated here across 7 different rates of progression
dat[which(dat$rate== unique(pe$slope)[1] )[o]: which(dat$rate== tail(unique(pe$slope),1) )[o],]$p <-  # record p-values at each run in 'dat'
foreach (s = 1:7, .combine='c') %dopar% {                                                           # parallelisation (7 cores employed to execute lines 77-81)
prog <- a
for (j in 2:num_series){ prog[j,neg] <- a[j,neg] - unique(pe$slope)[s]*(j-1)/2 }  # inject progression signal
poplr(prog)$cslp  # run PoPLR on the modified series to return p-val
}
# print(paste0('Px',i ,': ' ,k,' out of 15 iterations: ',o,' run(s) completed!'))  # 'live' report on progress in console
}
# compute power (proportion of p<0.05) and record in 'plot_res'
for (s in 1:7) { plot_res[s,]$pow <- length(which(dat[which(dat$rate==unique(dat$rate[s])),]$p<0.05))/100 }
# copy power from 'plot_res' to 'pe'
pe[which(pe$no==min(pe$no) & pe$id==unique(d$id)[i])[k] : which(pe$no==max(pe$no) & pe$id==unique(d$id)[i])[k], 9] <- plot_res$pow
# plot power curves #
x <- MD_slope
lines(x ,plot_res$pow*100, col='gray' )
print(paste0('Px',i ,': ' ,k,' out of 15 iterations completed!'))  # 'live' report on progress in console
} }
plot_avg(data=pe, i, legend='off')      # add average power curve
axis(2, cex.axis=1.6)
}
write.csv(pe, 'n5_power.csv')    # save result
rm(list=ls())
setwd('/Users/fabianyii/power')
# install.packages("remotes")
library(remotes)
# install_github("imarinfr/vf1/source")
# install.packages('RColorBrewer')
library("visualFields")
library('RColorBrewer')
library('plotrix')
source('code/vf_config.R')                              # load function to configure vf data based on 'visualFields' requirements
source('code/empty_plot.R')                             # '' create empty plot (argument: give title)
source('code/plot_indiv.R')                             # '' fit (15) individual curves for each px
source('code/plot_avg.R')                               # '' fit the average curve for each px
source('code/plot_grayscale_sparklines.R')              # grayscale with sparklines
# read raw data (power; n=12) into r
d <- read.csv('data/n5_power.csv'); d <- d[,-1]
# read visual field raw data into r & configuration
vf <- read.csv('data/power.csv'); vf <- vf[,-1]
vf <- vf_config(vf, npx=30, nrow=12)
# 30 colour codes for 30 patients
col <- c(brewer.pal(12, 'Paired'),brewer.pal(8, 'Dark2'),brewer.pal(8, 'Accent'),brewer.pal(8, 'Set2'))
############# Power vs Progression Signal for each patient (in separate plots) ##############
pdf(file='plots/plot_indiv.pdf', width=6, height=6)
for(i in 1:30){
empty_plot(data=vf, title=paste0('Px', i))                                    # create empty plot
plot_indiv(data=d, px=i)                                                       # fit all individual curves for 'i'th px
plot_avg(data=d, px=i, legend='on')                                            # fit the average curve for the 'i'th px
axis(2, cex.axis=1.6)
}
dev.off()
###################################### Done #################################################
################################ Grayscale with sparklines ##################################
pdf(file='plots/grayscale_sparklines_px.pdf', width=6, height=6)
num_VF <- 5 # number of VFs per series
lwd <- 2.5  # sparkline width
for(i in 1:30){
VF_series <- subset(vf, id==i)[1:num_VF,]   # extract 'num_VF' VFs from px i's VF series
mean_series <- vfmean(VF_series, by='eye') # mean of 'num_VF' VFs
grayscale_sparklines(vf=mean_series, vf_series=VF_series, 's', cex=0.01, lwd=lwd)
}
dev.off()
rm(list=ls())
setwd('/Users/fabianyii/power')
# install.packages("remotes")
library(remotes)
# install_github("imarinfr/vf1/source")
# install.packages('RColorBrewer')
library("visualFields")
library('RColorBrewer')
library('plotrix')
source('code/vf_config.R')                              # load function to configure vf data based on 'visualFields' requirements
source('code/empty_plot.R')                             # '' create empty plot (argument: give title)
source('code/plot_indiv.R')                             # '' fit (15) individual curves for each px
source('code/plot_avg.R')                               # '' fit the average curve for each px
source('code/plot_grayscale_sparklines.R')              # grayscale with sparklines
# read raw data (power; n=12) into r
d <- read.csv('data/n5_power.csv'); d <- d[,-1]
# read visual field raw data into r & configuration
vf <- read.csv('data/power.csv'); vf <- vf[,-1]
vf <- vf_config(vf, npx=30, nrow=12)
# 30 colour codes for 30 patients
col <- c(brewer.pal(12, 'Paired'),brewer.pal(8, 'Dark2'),brewer.pal(8, 'Accent'),brewer.pal(8, 'Set2'))
############# Power vs Progression Signal for each patient (in separate plots) ##############
pdf(file='plots/plot_indiv.pdf', width=6, height=6)
for(i in 1:30){
empty_plot(data=vf, title=paste0('Px', i))                                    # create empty plot
plot_indiv(data=d, px=i)                                                       # fit all individual curves for 'i'th px
plot_avg(data=d, px=i, legend='on')                                            # fit the average curve for the 'i'th px
axis(2, cex.axis=1.6)
}
dev.off()
###################################### Done #################################################
################################ Grayscale with sparklines ##################################
pdf(file='plots/grayscale_sparklines_px.pdf', width=6, height=6)
num_VF <- 5 # number of VFs per series
lwd <- 2.5  # sparkline width
for(i in 1:30){
VF_series <- subset(vf, id==i)[1:num_VF,]   # extract 'num_VF' VFs from px i's VF series
mean_series <- vfmean(VF_series, by='eye') # mean of 'num_VF' VFs
grayscale_sparklines(vf=mean_series, vf_series=VF_series, 's', cex=0.01, lwd=lwd)
}
dev.off()
